package seedu.nova.model.plan;

import java.io.Serializable;
import java.time.Duration;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import java.util.stream.IntStream;

import seedu.nova.model.Schedule;
import seedu.nova.model.schedule.event.Event;
import seedu.nova.model.util.time.TimeUtil;


/**
 * task inside plan, represents a soon-to-be-defined event for each day.
 */
public abstract class Task implements Serializable {
    protected TaskDetails details;
    protected TreeMap<LocalDate, Event> dayEventMap;
    protected Duration totalEventDuration;

    protected Task(TaskDetails details) {
        this.details = details;
        this.dayEventMap = new TreeMap<>();
        this.totalEventDuration = Duration.ZERO;
    }

    public TaskDetails getDetails() {
        return details;
    }

    public String getName() {
        return details.getName();
    }

    public int size() {
        return dayEventMap.size();
    }

    public List<Event> getEvents() {
        return new ArrayList<>(dayEventMap.values());
    }

    public Duration getBaseDuration() {
        return details.getDuration();
    }

    public TaskFreq getTaskFreq() {
        return details.getTaskFreq();
    }

    public TreeMap<LocalDate, Event> getDayEventMap() {
        return dayEventMap;
    }

    public Event getEventOn(LocalDate date) {
        switch (getTaskFreq()) {
        case WEEKLY:
            return dayEventMap.get(TimeUtil.getMondayOfWeek(date));
        case DAILY:
        default:
            return dayEventMap.get(date);
        }
    }

    public List<Event> getEventAfter(LocalDate date) {
        return new ArrayList<>(dayEventMap.tailMap(date).values());
    }

    /**
     * check if it is appropriate to generate an event on the date specified according to the task frequency
     *
     * @param date date
     * @return good?
     */
    public boolean hasEventOn(LocalDate date) {
        switch (getTaskFreq()) {
        case WEEKLY:
            return dayEventMap.containsKey(TimeUtil.getMondayOfWeek(date));
        case DAILY:
        default:
            return dayEventMap.containsKey(date);
        }
    }

    /**
     * Generate an event based on the day's schedule and specification of this task.
     * event is not added into day.
     *
     * @param date date to generate event on
     * @param sc   the schedule
     * @return event that is added. null if event not added
     * @throws ImpossibleTaskException when cannot generate event
     */
    public abstract Event generateEventOnDay(LocalDate date, Schedule sc) throws ImpossibleTaskException;

    /**
     * Add event that is related to the task.
     * For scheduler use only
     *
     * @param event event generated by this task
     * @return deleted?
     */
    public Event addEvent(Event event) {
        this.totalEventDuration = this.totalEventDuration.plus(event.getDtd().getDuration());
        switch (getTaskFreq()) {
        case WEEKLY:
            return this.dayEventMap.put(TimeUtil.getMondayOfWeek(event.getDate()), event);
        case DAILY:
        default:
            return this.dayEventMap.put(event.getDate(), event);
        }
    }

    /**
     * Delete event generated by the task.
     * For scheduler use only
     *
     * @param event event generated by this task
     * @return deleted?
     */
    public boolean deleteEvent(Event event) {
        if (deleteEventFromMap(event)) {
            this.totalEventDuration = this.totalEventDuration.minus(event.getDtd().getDuration());
            return true;
        } else {
            return false;
        }
    }

    /**
     * @param event
     * @return
     */
    private boolean deleteEventFromMap(Event event) {
        switch (getTaskFreq()) {
        case WEEKLY:
            return this.dayEventMap.remove(TimeUtil.getMondayOfWeek(event.getDate()), event);
        case DAILY:
        default:
            return this.dayEventMap.remove(event.getDate(), event);
        }
    }

    /**
     * List out all the events
     *
     * @return string of list of events
     */
    protected String listEvents() {
        final List<Event> lst = getEvents();
        return IntStream.range(0, lst.size())
                .mapToObj(i -> "(" + i + ")\n" + lst.get(i).toString() + "\n")
                .reduce("", (x, y) -> x + y);
    }

    @Override
    public String toString() {
        return details.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Task) {
            return details.equals(((Task) obj).details);
        } else {
            return super.equals(obj);
        }
    }
}
