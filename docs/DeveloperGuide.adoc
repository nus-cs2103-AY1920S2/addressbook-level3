= AddressBook Level 3 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level3/tree/master

By: `Team SE-EDU`      Since: `Jun 2016`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram2.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PomodoroDisplay`, `StatisticsDisplay`, `PetDisplay` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram2.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `TaskListParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a task).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user or highlighting the text input field with a certain color.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1, 2")` API call.

.Interactions Inside the Logic Component for the `delete 1, 2` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Task List, Pet, Pomodoro and statistics data.
* exposes an unmodifiable `ObservableList<Task>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Task List data in json format and read it back.
* can save the Pet data in json format and read it back.
* can save the Pomodoro data in json format and read it back.
* can save the Statistics data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// // tag::undoredo[ ]
// === [Proposed] Undo/Redo feature
// ==== Proposed Implementation

// The undo/redo mechanism is facilitated by `VersionedAddressBook`.
// It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
// Additionally, it implements the following operations:

// * `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
// * `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
// * `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

// These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

// Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

// Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

// image::UndoRedoState0.png[]

// Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

// image::UndoRedoState1.png[]

// Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

// image::UndoRedoState2.png[]

// [NOTE]
// If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

// Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

// image::UndoRedoState3.png[]

// [NOTE]
// If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

// The following sequence diagram shows how the undo operation works:

// image::UndoSequenceDiagram.png[]

// NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

// The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

// [NOTE]
// If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

// Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

// image::UndoRedoState4.png[]

// Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

// image::UndoRedoState5.png[]

// The following activity diagram summarizes what happens when a user executes a new command:

// image::CommitActivityDiagram.png[]

// ==== Design Considerations

// ===== Aspect: How undo & redo executes

// * **Alternative 1 (current choice):** Saves the entire address book.
// ** Pros: Easy to implement.
// ** Cons: May have performance issues in terms of memory usage.
// * **Alternative 2:** Individual command knows how to undo/redo by itself.
// ** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
// ** Cons: We must ensure that the implementation of each individual command are correct.

// ===== Aspect: Data structure to support the undo/redo commands

// * **Alternative 1 (current choice):** Use a list to store the history of address book states.
// ** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
// ** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
// * **Alternative 2:** Use `HistoryManager` for undo/redo
// ** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
// ** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// // end::undoredo[]

// // tag::dataencryption[]
// === [Proposed] Data Encryption

// _{Explain here how the data encryption feature will be implemented}_

// // end::dataencryption[]

=== Sorting

.Sequence of executing a sort command
image::SortSequenceDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/logic/commands/SortCommand.java[`SortCommand.java`]

==== Implementation
The tasklist has no default sorting set on it. It will only be sorted when the sort command is used like so `sort {field1}, {field2}, ...`.
First our Model accepts an array of Comparators which it will iterate through from the back to ensure that the first comparator is the highest sort order.

To implement this, we've augmented the UniqueTaskList and TaskList with a function setComparator. This allows us to set several comparators on the taskList to perform multi level sorting while maintaing the ObservableList which JavaFX can then use to update the UI.

=== AutoComplete

.Activity diagram of auto complete
image::AutoCompleteActivityDiagram.png[]

//tag::pomodoro[]
[[Pomodoro]]
=== Pomodoro
Pomodoro is activated by the `pom` command. It follows the same execution flow as many of the other commands in BBProductive.

.Interactions Inside Logic Component for the pom 1 command
image::PomSequenceDiagram.png[width=790]

==== Implementation
Pomosoero's features are implemented mainly in `seedu.address.logic` package. The `PomodoroManager` class is used to maniulate the timer and configure the relevant UI elements. The timer is facilitated by `javafx.animation.Timeline`.

When the `PomCommand` is executed, the `PomodoroManager` will handle the actual timer systems and update the relevant entities in the app. This is evident in the following sequence diagram.

.Interactions with PomodoroManager through a time cycle
image::PomExtendedSequenceDiagram.png[width=790]

Through the use of the Pomodoro feature, there are occasions where the app has to prompt the user for specific input in order to progress. This behaviour flow is represented in the _Pomodoro Acctivity_ diagram.

.Pomodoro Activity Diagram
image::PomodoroActivityDiagram.png[width=395]

The `PomodoroManager` maintains a  `prompt_state` indicating what the app might be prompting the user at a given time.

*Pomodoro Prompt States*

* `NONE`: There is no particular prompt happening. The default state when the app is in the neutral state. (i.e. No pomodoro running.)
* `CHECK_DONE`: This state occurs when a timer expires during a Pomodoro cycle.
* `CHECK_TAKE_BREAK`: This state occurs after user response has been received in the CHECK_DONE state.
* `CHECK_DONE_MIDPOM`: This state occurs when the user calls done on a task that is the Pomodoro running task.

Pomodoro has settings that can be configured by the user:

* Pomodoro Time: This defines how long the Pomodoro work period is. The default is 25 minutes.
* Break Time: This defines how long the breaks last in between Pomodoro periods. The default is 5 minutes.

This data is captured and stored in the `Pomodoro` class in `seedu.address.model`, which interacts with the app’s storage system. `PomodoroManager` also updates the `Pomodoro` model on what task is being run and the time remaining in a particular cycle. This allows the time progress to be persistent in between app closures and relaunches.

//end::pomodoro[]

=== Statistics Feature

The Statistics feature is mainly supported by the Statistics class, which in turn is facilitated by the CustomQueue class. Its class diagram is given below.

.Class Diagram of the Statistics Component
image::StatisticsClassDiagram.png[]

The Statistics feature does not support any commands explicitly. The UI is updated automatically when the 'stats' command is called. The following sequence diagram shows StatisticsDisplay is updated.

.Sequence Diagram of how Statistics
image::StatisticsUiSequenceDiagram.png[]

==== CustomQueue Implementation

The CustomQueue class enforces the following constraints.
1. Size of CustomQueue must be of `CONSTANT_SIZE` after each method call through Statistics.
2. DayData dates in CustomQueue must be only 1 day apart between its elements, and sorted from oldest to latest date.

[NOTE]
`CONSTANT_SIZE` can be set to any number. In our current implementation, we chose to store data for only the past 7 days to keep statistics simple and intuitive for users.

The CustomQueue class implements the following methods for other components to access or update its data:

* Model#updateDataDatesStatistics() - Updates data to current day while retaining stored data.
* Model#updatesDayDataStatistics() - Replaces existing DayData in Statistics with new DayData of the same date.
* Model#getDayDataFromDateStatistics() - Returns the DayData object from Statistics with the specified date.

==== Design considerations

===== Aspect: when to update StatisticsDisplay

* **Alternative 1 (current choice):** Update when the user runs the command to view Statistics
** Pros: Easy to implement.
** Cons: Progress can only be viewed at the Statistics tab.
* **Alternative 2:** Update when any changes are made to Statistics.
** Pros: In the event of future developments, any component of Statistics can be displayed at all times.
** Cons: Need to keep track of all instances that can modify Statistics' values.

===== Aspect: Data structure to support Statistics

* **Alternative 1 (current choice):** Use a list that stores a fixed number of DayData objects, with elements being strictly 1 day apart and sorted from oldest to latest date.
** Pros: Lightweight, does not store unnecessary data. Easy to pass data to generate graphs. Systematic removal of outdated data.
** Cons: Need to enforce constraints in methods.
* **Alternative 2:** Use a list with elements sorted from oldest to latest date.
** Pros: Easy to implement.
** Cons: Harder to pass data to generate graphs. Need to handle outdated dates.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of tasks
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps
* need motivation to get things done

*Value proposition*: We integrate a Pomodoro-Pet environment into a full fledged task manager. The pet system serves to gamify the act of doing tasks, thereby motivating users, and the Pomodoro helps users get into a regular work/rest cycle. This integrationcovers all aspects of productivity in line platform. It covers motivation, organising of tasks and also how to go about doing them. This all in one solution is seldom found in other applications which implement maybe 1 or 2 of these features.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |view all current ongoing tasks |manage my tasks and time

|`* * *` |user |able to edit my task description |make changes in the event something unexpected happens

|`* * *` |user |add a task by specifying a task description only |record tasks that needs to be done.

|`* * *` |user |add a task by specifying a task description and a reminder |record tasks that needs to be done by a specific period

|`* * *` |user |sort upcoming tasks by date |filter out the latest/oldest tasks according to my needs

|`* * *` |user |sort my tasks by priority |manage my tasks

|`* * *` |user |delete a task |remove tasks that I no longer care to track

|`* * *` |user |utilise the Pomodoro technique to break down my work into structured intervals |boost productivity and keep track of time

|`* * *` |user |be able to remind myself on when I plan to work on a task |be on track to complete my tasks

|`* * *` |user |get a visual cue from my pet to prompt me to do work|be motivated to work when my productivity is low

|`* * *` |user |keep track of the time spent on each task |check my progress

|`* *` |pro user |navigate commands using shortcuts |save more time

|`* *` |pro user |delete several tasks at once |save more time

|`* *` |pro user |mark several tasks done at once |save more time

|`* *` |pro user |customise the rate at which I should do work in the Pomodoro |fit my workstyle better

|`* *` |pro user |automate when my done tasks are cleared |customise when I want my tasks to be removed

|`* *` |user |view the total number of tasks/duration spent on tasks I have done over a period of time |track my productivity over different periods

|`* *` |user |view the durations in which I have currently spent on different tasks |better allocate my time

|`* *` |user |see my pet grow because of my productivity |am more motivated to stay productive

|`*` |user |be greeted by a cute mascot |feel happy and motivated to do work


|=======================================================================

[appendix]
//tag::usecase[]
[[UseCases]]
== Use Cases

(For all use cases below, the *System* is `BBProductive` and the *Actor* is the `user`, unless specified otherwise)

.Use case diagram for BBProductive
image::use_cases.png[width=790]

[discrete]

=== Use Case: UC01 - View tasks

*MSS*

1. User requests to see the task list.
2. BB Productive displays the view under the tasks tab.
+
Use case ends.

[discrete]

=== Use Case: UC02 - Add task

*MSS*

1. User requests to add a task to the task list.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. Task of the same name already exists.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list"_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC03 - Done task

*MSS*

1. User requests to set a task to done.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. Task specified by user already marked as done.
+
[none]
** 1a1. BBProductive shows _"Task has already been marked as done!"_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index.
+
[none]
** 1b1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[none]
* 2a. A pommed task is among the tasks to be set to done.
+
[none]
** 2a1. BBProductive prompts user if they want to `pom` another task, or `N` to return the app to neutral.
** 2a2. If user `pom` another task, use case resumes at stage 2 of UC09.
+
Use case ends.

[discrete]

=== Use Case: UC04 - Edit task

*MSS*

1. User requests to update a task with updated fields and informs the task list.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index
+
[none]
** 1b1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC05 - Set a reminder for a task

*MSS*

1. User requests to set a task with a Reminder.
2. BB Productive creates/updates a task and shows the view with updated task list.
3. A reminder pops up when the specified time has elapsed.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC06 - Set a task to recurring

*MSS*

1. User requests to set a task to be a recurring task.
2. BB Productive creates/updates a task and shows the view with updated task list.
3. A reminder pops up when the specified time has elapsed.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC07 - Delete task

*MSS*

1.  User requests to list tasks.
2.  BBProductive shows a list of tasks.
3.  User requests to delete a specific person in the list.
4.  BBProductive deletes the task.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index.
+
[none]
** 1b1. BBProductive shows _"Invalid command format!"_ in response box.
+
Use case ends.

[none]
* 1c. Task to be deleted is being pommed.
+
[none]
** 1c1. BBProductive shows _"You can't delete a task you're pom-ming!"_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC08 - Sort tasks

*MSS*

1.  User requests to list tasks.
2.  BBProductive shows a list of tasks.
3.  User requests to sort the list by one or more parameters.
4.  BBProductive creates a new view and updates the task list view.
+
Use case ends.

[discrete]

=== Use Case: UC09 - Start pomodoro

*MSS*

1.  User requests to start pomodoro on a specific task.
2.  BBProductive starts timer and sets task-in-progress to said task.
3.  Pomodoro timer expires.
4.  BBProductive sets task-in-progress to null and prompts user if user has done the task.
5.  User replies the affirmative.
6.  BBProductive shows view with updated task list with done task. Pet adds additional points.
7.  BBProductive prompts user if user wants to do break time.
8.  User replies the affirmative.
9.  BBProductive starts break timer.
10. Break timer expires.
11. BBProductive returns to neutral state.
+
Use case ends.

*Extensions*

[none]
* 1a. User fed in an invalid index.
+
[none]
** 1a1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[none]
* 1b. Task specified by user already marked as done.
+
[none]
** 1b1. BBProductive shows _"Task has already been marked as done!"_ in response box.
+
Use case ends.

[none]
* 5a. User replies negative.
+
[none]
** 5a1. BBProductive will leave the task list as is.
+
Use case resumes at stage 7.

[none]
* 5b. User replies with answer that is neither `Y/y` nor `N/n`.
+
[none]
** 5b1. BBProductive will leave the task list as is.
+
Use case resumes at stage 7.

[none]
* 8a. User replies negative.
+
[none]
** 8a1. BBProductive will start no timer.
+
Use case resumes at stage 11.

[discrete]

=== Use Case: UC10 - View stats

*MSS*

1.  User requests to see the statistics tab.
2.  BBProductive displays the view under the statistics tab.
+
Use case ends.

[discrete]
=== Use Case: UC11 - View settings

*MSS*

1.  User requests to see the settings tab.
2.  BBProductive displays the view under the settings tab.
+
Use case ends.

[discrete]
=== Use Case: UC12 - Set settings

*MSS*

1.  User requests to update the app's settings.
2.  BBProductive takes the input and updates the app's internal settings.
3.  User requests to see the settings tab.
4.  BBProductive displays the view under the settings tab with the updated preferences.
+
Use case ends.

//end::usecase[]

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 tasks without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Graphics should not be offensive to any culture in any way.
.  Product should be fully functional with CLI alone.
.  Storage should be done in a human readable and editable format.
.  Commands should be user-friendly.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[pomodoro]] Pomodoro::
A time management method developed by Francesco Cirillo. Traditionally, cycles of 25 minutes of work and 5 minutes of rest.

[[task]] Task::
A snippet of text specified by the user that can be tracked (done/time spent).

[[pet]] Pet::
A cute little companion whom the player can care for and accessorise with more tasks being done.

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
