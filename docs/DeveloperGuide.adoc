= BBProductive - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103T-W16-1/main

By: `Team SE-EDU`      Since: `Jun 2016`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram2.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

//tag::ui[]

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PomodoroDisplay`, `StatisticsDisplay`, `PetDisplay` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

//end::ui[]

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram2.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `TaskListParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a task).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user or highlighting the text input field with a certain color.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1, 2")` API call.

.Interactions Inside the Logic Component for the `delete 1, 2` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Task List, Pet, Pomodoro and statistics data.
* exposes an unmodifiable `ObservableList<Task>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Task List data in json format and read it back.
* can save the Pet data in json format and read it back.
* can save the Pomodoro data in json format and read it back.
* can save the Statistics data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== TaskList
==== Add(Permas)

==== Edit(Arthur)

==== Done
The done feature allows the user to mark a task as done. The method `executeCommand` is called and then `parseCommand` method is executed to return create a 
DoneCommandParser. it then creates a DoneCommand object and is return to LogicManager. After which, the `execute` command is called from the DoneCommand object which then sends updates to model. Once done, a DoneCommandResult object is returned to LogicManager.

.Sequence Diagram of Done command
image::DoneCommadSequenceDiagram.png[width=790]

==== Delete
The delete feature allows the user to delete a task, regardless of whether it is marked as done. The LogicManager first executes the user input and this will create a DeleteCommandParser object. It then calls the method `Parse()` which creates a DeleteCommand object which will be returned to LogicManager. LogicManager then calles the `execute` method of the DeleteCommand object. This will then tell the model which task to delete. Once done, a CommandResult object will be returned to LogicManager.

.Sequence Diagram of Done command
image::DoneCommadSequenceDiagram.png[width=790]


//tag::branson[]
=== Sort
==== Implementation
*API* : link:{repoURL}/src/main/java/seedu/address/logic/commands/SortCommand.java[`SortCommand.java`]

.Sequence of executing a sort command
image::SortSequenceDiagram.png[]
The sort command takes in a list of fields and generates FieldComparators as seen in the diagram and then uses Comparator.thenComparing to aggregate the comparators. The first field provided will be of the highest sort order. The Model will then set the aggregated comparator on the `TaskList`.

.Class diagram of SortedList
image::SortedListClassDiagram.png[]
We use a new SortedList from JavaFx within TaskList because FilteredList does not allow for sorting. As such we have the FilteredList reference the SortedList and the SortedList refernce the UniqueTaskList. By warpping the lists around another, this allows the SortedList and FilteredList to read changes to the UniqueTaskList and perform the appropriate filtering and sorting.

.Sequence of initializing the Sorted List
image::SortInitliazeDiagram.png[]

Due to the requirements mentioned, this is how we generate our FilteredList. We set FilteredList to reference the SortedList and then the SortedList to reference the UniqueTaskList.

==== Updating UI
image::SortUiSequenceDiagram.png[]

Meanwhile to update the UI on the newest sorting order, the latest sortOrder is set on the `TaskList`. The LogicManager is then able to access the sort order through the Model and provide the `MainWindow` with the sort order. The MainWindow then sets it on the `TaskListPanel`.

SortCommandResult extends CommandResult and contains an additional String attribute `sortOrder`.

=== AutoComplete
Auto complete is triggered when users press tab while focussed on the command line.

==== Implementation
.AutoComplete Sequence Diagram
image::ACSequenceDiagram.png[]

When a user presses tab on the command line, a key event handler in the CommandBox calls the suggestCommand function of MainWindow with the user input. The MainWindow then passes the user input through the LogicManager to the CommandCompletor. +

The input is pass through the LogicManager so that we can get TaskList details from the LogicManager and transfer it to the CommandCompletor (e.g. taskList length). The CommandCompletor then parses the input and returns one of three things which lead to different changes to the UI:

. CompletorResult
.. Will cause CommandBox to setSuccess on CommandTextField
. CompletorDeletionResult [inherits from CompletorResult]
.. Contains deleted input which will be shown as feedback
.. Will cause MainWindow to call setWarning on ResultDisplay
. CompletorException
.. Will cause CommandBox to setFailure on CommandTextField

==== Auto Complete Overview
.Activity diagram of auto complete
image::ACActivityDiagram.png[width=790]
[IMPORTANT]
=====
Auto completion of a word happens when either:

. the input matches the start of a target word
. the edit distance between the input and the target < 2.
=====
[#completion criteria]

The above diagram provides a big picture overview of decisions `CommandCompletor` goes through when processing user input.

. It attempts to complete the command word as in the callout above
.. if command word is unrecognized, `CommandCompletor` throws a `CompletorException` which leads to Unknown Command UI
.. else it performs argument checks and auto completes as necessary

===== Argument checks overview

. If the input is an add/edit/pom command then CommandCompletor will attempt to add prefixes.
.. add/edit command -> add priority and reminder prefixes
... Edit auto complete will only add prefixes after the second word to avoid adding a prefix to the compulsory INDEX field of edit commands
.. pom command -> add timer prefix
. If input is a delete/done command
.. remove any invalid indices that are greater than the length of the displayed task list or that are not a positive integer
. If input is a sort command
.. Auto completion of fields is performed based on the <<completion criteria>>
.. If the field is not recongized, then it is removed

==== Auto Complete output:
As seen from the activity diagram above:

. Known Command UI displayed when:
.. Any kind of completion has happened or nothing has changed for the input
... `CompletorResult` is returned
.. Any input is deleted (invalid index or sort field)
... `CompletorDeletionResult` is returned
. Unknown Command UI is displayed when:
.. Command word provided is not recognized
... CompletorException` is raised

==== Known Command UI

.AutoComplete Success UI
image::ACSuccess.png[width=600]

* `CommandTextField` is set to green
* `CommandTextField` text is replaced by the suggested command
* Feedback is also provided on what changes have been made
** If input has been removed, `ResultDisplay` is set to orange

==== Unknown Command UI

.AutoComplete Failure UI
image::ACFailure.png[width=500]

* `CommandTextField` is set to red
* `CommandTextField` text is unchanged
* Feedback is provided that command word is not recognized

==== Prefix Completion
image::ACPrefixActivityDiagram.png[]

Here we take a closer look at how prefix completion is implemented. We iterate through every word of the user's input and then check if the word is a valid task field. If it is, we append the prefix and update the hasPrefix boolean to true so that we don't append duplicate prefixes. The input is then updated and we continue iterating.

==== Index Completion
image::ACIndexActivityDiagram.png[]

Similar to before, we iterate through the arguments and we remove indexes that are either out of the displayed TaskList's size or that is not a positive integer. We then append it to a removed list so that we can inform the user what input has been removed.

==== Sort field Completion
Sort field completion is done by iterating through all arguments word by word and performing the auto complete checks against all possible sort fields. The auto complete checks were the same as the above <<completion criteria>>.

=== Enhanced Find
We've built upon the existing find function in AB-3 to filter tasks based on phrases instead of words.

==== Implementation

.Find Command Sequence diagram
image::FindSequenceDiagram.png[]

* After setting the predicate on the model and FilteredList, the FilteredList will apply the Test method of the predicate.
** Scoring will be discussed in the next section.
* A comparator is then retrived from the Predicate and is then used to display more relevant search results to the user
* Any existing comparator set is removed when `setSearchResultOrder` is called on Model

==== Predicate

.Scoring decision
All tasks will initially have a score of 2 and based on the below criteria, the score will be adjusted. Only tasks with scores < 2 will be displayed.

image::PredicateSequenceDiagram.png[]

===== Name scoring
* The name score of a task is the minimum score of all chunks of the name
** A chunk is a String subsequence of the task name that has the same number of words as the search term
* We iterate through all chunks of the task name and calculate a score for each chunk
** The minimum of these scores is set as the task's overall name score
** a smaller score means a more relevant task
* The calculation of a chunk is decided by:
** edit distance between one of the chunks and the search term < 2, score is set to 1
** search term matches the start of one of the chunks, score is set to 1
** one of the chunks is the same as the search term, score is set to 0

===== Tag scoring
Tag scoring is carried out on top of name scoring. For every tag in the search term that appears in a Task, we decrement the Task's name score by 1.

The combination of name and tag score is then used as a Task's final score in determining it's relevance in the search results.

==== Other Considerations
* We chose to not use edit distance for search terms of string length less than 3 as this would bring about alot of false positives given that that the edit distance between words of length < 3 will easily be 1
* We also chose to display task names who's start matches the search term for ease of usage even though the edit distance could be significant.
//end::branson[]

//tag::pomodoro[]
[[Pomodoro]]
=== Pomodoro
Pomodoro is activated by the `pom` command. It follows the same execution flow as many of the other commands in BBProductive.

.Interactions Inside Logic Component for the pom 1 command
image::PomSequenceDiagram.png[width=790]

==== Implementation
Pomosoero's features are implemented mainly in `seedu.address.logic` package. The `PomodoroManager` class is used to maniulate the timer and configure the relevant UI elements. The timer is facilitated by `javafx.animation.Timeline`.

When the `PomCommand` is executed, the `PomodoroManager` will handle the actual timer systems and update the relevant entities in the app. This is evident in the following sequence diagram.

.Interactions with PomodoroManager through a time cycle
image::PomExtendedSequenceDiagram.png[width=790]

Through the use of the Pomodoro feature, there are occasions where the app has to prompt the user for specific input in order to progress. This behaviour flow is represented in the _Pomodoro Acctivity_ diagram.

.Pomodoro Activity Diagram
image::PomodoroActivityDiagram.png[width=395]

The `PomodoroManager` maintains a  `prompt_state` indicating what the app might be prompting the user at a given time.

*Pomodoro Prompt States*

* `NONE`: There is no particular prompt happening. The default state when the app is in the neutral state. (i.e. No pomodoro running.)
* `CHECK_DONE`: This state occurs when a timer expires during a Pomodoro cycle.
* `CHECK_TAKE_BREAK`: This state occurs after user response has been received in the CHECK_DONE state.
* `CHECK_DONE_MIDPOM`: This state occurs when the user calls done on a task that is the Pomodoro running task.

Pomodoro has settings that can be configured by the user:

* Pomodoro Time: This defines how long the Pomodoro work period is. The default is 25 minutes.
* Break Time: This defines how long the breaks last in between Pomodoro periods. The default is 5 minutes.

This data is captured and stored in the `Pomodoro` class in `seedu.address.model`, which interacts with the app’s storage system. `PomodoroManager` also updates the `Pomodoro` model on what task is being run and the time remaining in a particular cycle. This allows the time progress to be persistent in between app closures and relaunches.
//end::pomodoro[]

// tag::reminder[]
=== Reminders
The user's reminder functionality is achieved by calculating the time delay from the current time and the time from the user input. This time delay as well as the Task name and description is passed to the MainWindow for the reminder to be triggered as a pop up at the right time.

==== Implementation
A `DateTimeFormatter` is used to parse the date time from the user input, which is just the date in the r/ flag when adding or editing a task, into a `LocalDateTime` object. This `LocalDateTime` is used to store the date and time information. When the reminder is instantiated, a `setDelay` method is called setting in motion the calculation of time delay between the current time and the reminder time, and triggering of reminder on the `MainWindow`. The reminder class is stored as an `Optional` in the Task class itself.

Reminder is stored as a string in the `JsonAdaptedTask`. This string contains the exact format of the date and time that the user inputs, this allows the same constructor to be used when the data is read and changed to a task and thus reminder object. A sequence diagram of the reminder flow is shown below for reference.

.Reminder Sequence Diagram
image::ReminderSequenceDiagram.png[width=790]

// end::reminder[]

// tag::recurring[]
=== Recurring
The user's recurring tasks functionality is twofold. Resetting the task to be unfinished after the stipulated time interval and resetting the task's reminder date according to the stipulated time interval. The behaviour for this recurring feature is mainly represented in the activity diagram below.

.Recurring Activity Diagram
image::RecurringActivityDiagram.png[width=790]

==== Implementation
The logic is mainly implemented in the `Recurring` class and `ModelManager` class in `seedu.address.model`, which interacts with the app’s storage system especially with respect to task storage. This `Recurring` instance is stored in `Task` as an optional field.

In the `Recurring` class, whenever a task is added or edited, the recurring type is then parsed to be either daily or weekly. Afterward, based on the time the recurring attribute is added, a reference LocalDateTime is noted in the `Recurring` instance itself. This ensures that the first recurring behaviour will trigger in the given interval with respect to that referenceDateTime and following the same interval afterwards.

The recurring behaviour is orchestrated in `ModelManager` whenever a task is added or edited, a `setTask` method is called that will generate a `Timer` and `TimerTask`. A `TimerTask` is the logic run to update the task, namely resetting the done and the reminder accordingly. The `Timer` schedules `TimerTasks` at a fixed rate based on the the time interval chosen, if it is daily it will be every 24 hours (but for testing purposes it will be every 60 seconds) and if it is weekly it will be every 7 days. There is only 1 `Timer` for the `ModelManager` that handles the scheduling of each `TimerTask` that corresponds to every task that has a recurring behaviour. On boot the `Timer` is canceled and replaced with a new instance, subsequently all the tasks are iterated through. Every task with a recurring attribute will have a `TimerTask` generated and scheduled accordingly.

The recurring behaviour triggered will set the task as undone. If a reminder exists and has been triggered, it will increment the reminder to be the next day or week depending on the interval set. When the recurring behaviour is triggered, the result display will show a message that the recurring task has been reset.

Additionally, a flag has been made to check if the task needs to be changed, if it does not it will not be unnecessarily updated in the `Model`. A class diagram of the tasks and all its attributes is shown below.

Recurring is stored as a string in the `JsonAdaptedTask`. This string contains the LocalDateTime information for the reference date as well as the type of interval itself. A special constructor for this string is used to reconstruct the recurring attribute when reading from storage.

.Task Class Diagram with all aforementioned attributes including recurring and reminder
image::TaskClassDiagram.png[width=790]
// end::recurring[]

//tag::statistics[]

=== Switch Tab Feature

The Switch tab feature allows the user to traverse between the Tasks, Statistics and Settings tabs.

The user can switch tabs through 2 main methods:
1. User calls a valid SwitchTabCommand that displays the appropriate tab defined.
2. User calls a valid command that changes the display of Tab B while he or she is on Tab A. In this scenario, Tab B will display automatically.

This behaviour is represented in the following activity diagram.

.Activity Diagram of Tab Switches
image::SwitchTabActivityDiagram.png[]

The following sequence diagram shows how the SwitchTabCommand updates the tab in the UI.

.Sequence Diagram of SwitchTabCommand
image::SwitchTabSequenceDiagram.png[]

=== Statistics Feature

The Statistics feature allows the user to view information about their number of tasks completed and Pomodoro duration ran on a daily basis for the past `CONSTANT_SIZE` days.

[NOTE]
`CONSTANT_SIZE` can be set to any number for any future developments. In our current implementation, we chose to store data for only the past 7 days to keep statistics simple and intuitive for users.

==== Implementation
The Statistics feature is mainly supported by the Statistics class, which in turn is facilitated by the CustomQueue class. Its class diagram is given below.

.Class Diagram of the Statistics Component
image::StatisticsClassDiagram.png[]

The Statistics feature does not support any explicit commands. Instead, the UI is updated and displayed when the SwitchTabCommand 'stats' is called.

Step 1. MainWindow receives the SwitchTabCommandResult commandResult from Logic.

Step 2. MainWindow calls StatisticsManager#updateStatisticsDisplayValues() which retrieve the latest Statistics from Model and generates the display information.

Step 3. MainWindow then retrieves these display information from StatisticsManager and sets this information in StatisticsDisplay.

[NOTE]
SwitchTabCommand also switches the focused tab to the Statistics tab to display the results to the user.

The following sequence diagram shows how the statistics is updated to the display.

.Sequence Diagram of how Statistics
image::StatisticsUiSequenceDiagram.png[]

==== CustomQueue Implementation

The `CustomQueue` class enforces the following constraints.
1. Size of `CustomQueue` must be of `CONSTANT_SIZE` after each method call through `Statistics`.
2. DayData dates in `CustomQueue` must be only 1 day apart between its elements, and sorted from oldest to latest date.

The `CustomQueue` class implements the following methods for other components to access or update its data:

* Model#updateDataDatesStatistics() - Updates data to current day while retaining stored data.
* Model#updatesDayDataStatistics() - Replaces existing DayData in Statistics with new DayData of the same date.
* Model#getDayDataFromDateStatistics() - Returns the DayData object from Statistics with the specified date.

==== Design considerations

===== Aspect: when to update StatisticsDisplay

* **Alternative 1 (current choice):** Update when the user runs the command to view Statistics
** Pros: Easy to implement.
** Cons: Progress can only be viewed at the Statistics tab.
* **Alternative 2:** Update when any changes are made to Statistics.
** Pros: In the event of future developments, any component of Statistics can be displayed at all times.
** Cons: Need to keep track of all instances that can modify Statistics' values.

===== Aspect: Data structure to support Statistics

* **Alternative 1 (current choice):** Use a list that stores a fixed number of DayData objects, with elements being strictly 1 day apart and sorted from oldest to latest date.
** Pros: Lightweight, does not store unnecessary data. Easy to pass data to generate graphs. Systematic removal of outdated data.
** Cons: Need to enforce constraints in methods.
* **Alternative 2:** Use a list with elements sorted from oldest to latest date.
** Pros: Easy to implement.
** Cons: Harder to pass data to generate graphs. Need to handle outdated dates.

//end::statistics[]

=== Pet

==== Implementation
The pet feature aims to provide a virtual pet for the app in order to motivate the user. The pet has three main components: the XP points, the evolution and the mood. To facilitate this function, a Pet class is created to represent the pet. A PetManager class is created to manage the pet via communications from MainWindow. Lastly, a PetDisplay class is created to handle the UI of the pet.

.Pet Class Diagram
image::PetClassDiagram.png[]

To exemplify the implementation for the components of the XP points and the evolution of the pet, an example usage scenario is given below.

Step 1. User finishes a task. User calls the done command for the task. MainWindow would execute this command and generate a DoneCommandResult object

image::DoneCommandSequenceDiagram.png[]

Step 2. The MainWindow will update PetManager to increase XP points after the DoneCommandResult Object is received. This is done by calling the method `PetManager#incrementExp`. PetManager would then update XP points of Pet by calling `Pet#incrementExp`. This method also checks whether the XP points have reached the milestones for the levels and will update the level of the pet accordingly.

.Pet Sequence Diagram
image::PetSequenceDiagram.png[]

Step 3. Following the update of XP points, MainWindow also updates the mood of the pet. Supposedly, the pet is originally in "HANGRY" mood, MainWindow will call "MainWindow#updateMoodWhenDone" method to change the pet's mood to Happy. It will also update the time of the last done task and reschedules a new timertask so that the pet will turn "Hangry" at the correct time. Lastly, this method also updates the elements

Step 4. MainWindow would then update the string of the filepaths for the respective UI elements in PetDisplay by executing the method `PetManager#updateDisplayElements`.

Step 5. Lastly, MainWindow will the update PetDisplay. The user will then see the UI be updated accodingly. For example, the progress bar would increase.

.update PetDisplay Diagram
image::UpdatePetDisplaySequenceDiagram.png[]

==== Design Consideration

=== Set Commands

.Set command class diagram
image::SetClassDiagram.png[]

The Set Commands can be used to customise the features in BB Productive. It can be used to customised the name of the pet, the duration for pomodoro and the daily challenge target so as to better cater to the needs of the user.

Below is an example scenario when the user runs the set command.

Step 1. User runs the command "Set pet/momu pom/30 daily/150". MainWindow will take the user input and call upon LogicManager to pasrse it. LogicManager will the call AddressBookParser which in creates a SetcommandPArser object and then parse the user argument. A SetCommand object is then executed and returned to logic.

.Set command sequence diagram
image::SetCommandSequenceDiagram.png[]

Step 2. Logic calls upon the method `SetCommand#execute` which eventually calls the methods `Model#SetPetName` and `Model#setPomodoroDefaultTime`. A SetCommandResult object is return once these methods are executed.

Step 3. Upon receiving the SetCommandResult object, MainWindow then calls the method `MainWindow:UpdatePetDisplay` to update the UI for Pet. It also calls `PomodormoManager#SetDefaultStartTime` and `PomdooroDisplay#setTimerText` to update the Ui of pomodoro. Lastly, `StatisticsManager#setDailyTarget` is called to update the value of the dailyTargetText.

.set command updating Ui
image::SetCommandUpdatingUi.png[]

==== Design Consideration
=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of tasks
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps
* need motivation to get things done

*Value proposition*: We integrate a Pomodoro-Pet environment into a full fledged task manager. The pet system serves to gamify the act of doing tasks, thereby motivating users, and the Pomodoro helps users get into a regular work/rest cycle. This integrationcovers all aspects of productivity in line platform. It covers motivation, organising of tasks and also how to go about doing them. This all in one solution is seldom found in other applications which implement maybe 1 or 2 of these features.

// tag::userStories[]
[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |view all current ongoing tasks |manage my tasks and time

|`* * *` |user |able to edit my task description |make changes in the event something unexpected happens

|`* * *` |user |add a task by specifying a task description only |record tasks that needs to be done.

|`* * *` |user |add a task by specifying a task description and a reminder |record tasks that needs to be done by a specific period

|`* * *` |user |add a task that is recurring |record tasks that are either recurring daily or weekly without having to input it every day or week

|`* * *` |user |sort upcoming tasks by date |filter out the latest/oldest tasks according to my needs

|`* * *` |user |sort my tasks by priority |manage my tasks

|`* * *` |user |delete a task |remove tasks that I no longer care to track

|`* * *` |user |utilise the Pomodoro technique to break down my work into structured intervals |boost productivity and keep track of time

|`* * *` |user |be able to remind myself on when I plan to work on a task |be on track to complete my tasks

|`* * *` |user |get a visual cue from my pet to prompt me to do work|be motivated to work when my productivity is low

|`* * *` |user |keep track of the time spent on each task |check my progress

|`* *` |pro user |navigate commands using shortcuts |save more time

// |`* *` |pro user |delete several tasks at once |save more time

// |`* *` |pro user |mark several tasks done at once |save more time

|`* *` |pro user |customise the rate at which I should do work in the Pomodoro |fit my workstyle better

|`* * *` |pro user |be able to remind myself on a recurring basis for repetitive tasks |be on track to complete my tasks, including those that are repetitive and also done on a recurring basis

// |`* *` |pro user |automate when my done tasks are cleared |customise when I want my tasks to be removed

|`* *` |user |view the total number of tasks/duration spent on tasks I have done over a period of time |track my productivity over different periods

|`* *` |user |view the durations in which I have currently spent on different tasks |better allocate my time

|`* *` |user |see my pet grow because of my productivity |am more motivated to stay productive

|`*` |user |be greeted by a cute mascot |feel happy and motivated to do work


|=======================================================================
// end::userStories[]

[appendix]

//tag::usecase[]
[[UseCases]]
== Use Cases

(For all use cases below, the *System* is `BBProductive` and the *Actor* is the `user`, unless specified otherwise)

.Use case diagram for BBProductive
image::use_cases.png[width=790]

[discrete]

=== Use Case: UC01 - View tasks

*MSS*

1. User requests to see the task list.
2. BB Productive displays the view under the tasks tab.
+
Use case ends.

[discrete]

=== Use Case: UC02 - Add task

*MSS*

1. User requests to add a task to the task list.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. Task of the same name already exists.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list"_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC03 - Done task

*MSS*

1. User requests to set a task to done.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. Task specified by user already marked as done.
+
[none]
** 1a1. BBProductive shows _"Task has already been marked as done!"_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index.
+
[none]
** 1b1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[none]
* 2a. A pommed task is among the tasks to be set to done.
+
[none]
** 2a1. BBProductive prompts user if they want to `pom` another task, or `N` to return the app to neutral.
** 2a2. If user `pom` another task, use case resumes at stage 2 of UC09.
+
Use case ends.

[discrete]

=== Use Case: UC04 - Edit task

*MSS*

1. User requests to update a task with updated fields and informs the task list.
2. BB Productive shows view with updated task list.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index
+
[none]
** 1b1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC05 - Set a reminder for a task

*MSS*

1. User requests to set a task with a Reminder.
2. BB Productive creates/updates a task and shows the view with updated task list.
3. A reminder pops up when the specified time has elapsed.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC06 - Set a task to recurring

*MSS*

1. User requests to set a task to be a recurring task.
2. BB Productive creates/updates a task and shows the view with updated task list.
3. A reminder pops up when the specified time has elapsed.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC07 - Delete task

*MSS*

1.  User requests to list tasks.
2.  BBProductive shows a list of tasks.
3.  User requests to delete a specific person in the list.
4.  BBProductive deletes the task.
+
Use case ends.

*Extensions*

[none]
* 1a. New task name matches that of another task.
+
[none]
** 1a1. BBProductive shows _"This task already exists in the task list."_ in response box.
+
Use case ends.

[none]
* 1b. User fed in an invalid index.
+
[none]
** 1b1. BBProductive shows _"Invalid command format!"_ in response box.
+
Use case ends.

[none]
* 1c. Task to be deleted is being pommed.
+
[none]
** 1c1. BBProductive shows _"You can't delete a task you're pom-ming!"_ in response box.
+
Use case ends.

[discrete]

=== Use Case: UC08 - Sort tasks

*MSS*

1.  User requests to list tasks.
2.  BBProductive shows a list of tasks.
3.  User requests to sort the list by one or more parameters.
4.  BBProductive creates a new view and updates the task list view.
+
Use case ends.

[discrete]

=== Use Case: UC09 - Start pomodoro

*MSS*

1.  User requests to start pomodoro on a specific task.
2.  BBProductive starts timer and sets task-in-progress to said task.
3.  Pomodoro timer expires.
4.  BBProductive sets task-in-progress to null and prompts user if user has done the task.
5.  User replies the affirmative.
6.  BBProductive shows view with updated task list with done task. Pet adds additional points.
7.  BBProductive prompts user if user wants to do break time.
8.  User replies the affirmative.
9.  BBProductive starts break timer.
10. Break timer expires.
11. BBProductive returns to neutral state.
+
Use case ends.

*Extensions*

[none]
* 1a. User fed in an invalid index.
+
[none]
** 1a1. BBProductive shows _"Invalid command format! "_ in response box.
+
Use case ends.

[none]
* 1b. Task specified by user already marked as done.
+
[none]
** 1b1. BBProductive shows _"Task has already been marked as done!"_ in response box.
+
Use case ends.

[none]
* 5a. User replies negative.
+
[none]
** 5a1. BBProductive will leave the task list as is.
+
Use case resumes at stage 7.

[none]
* 5b. User replies with answer that is neither `Y/y` nor `N/n`.
+
[none]
** 5b1. BBProductive will leave the task list as is.
+
Use case resumes at stage 7.

[none]
* 8a. User replies negative.
+
[none]
** 8a1. BBProductive will start no timer.
+
Use case resumes at stage 11.

[discrete]

=== Use Case: UC10 - View stats

*MSS*

1.  User requests to see the statistics tab.
2.  BBProductive displays the view under the statistics tab.
+
Use case ends.

[discrete]
=== Use Case: UC11 - View settings

*MSS*

1.  User requests to see the settings tab.
2.  BBProductive displays the view under the settings tab.
+
Use case ends.

[discrete]
=== Use Case: UC12 - Set settings

*MSS*

1.  User requests to update the app's settings.
2.  BBProductive takes the input and updates the app's internal settings.
3.  User requests to see the settings tab.
4.  BBProductive displays the view under the settings tab with the updated preferences.
+
Use case ends.

//end::usecase[]
//tag::nfr[]

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 tasks without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Graphics should not be offensive to any culture in any way.
.  Product should be fully functional with CLI alone.
.  Storage should be done in a human readable and editable format.
.  Commands should be user-friendly.

//end::nfr[]

[appendix]
//tag::glossary[]
== Glossary
[%header,cols="2,6"]
|===

|Term
|Detail

|Mainstream OS
|Windows, Linux, Unix, OS-X

|Pomodoro [[pomodoro]]
|A time management method developed by Francesco Cirillo. Traditionally, cycles of 25 minutes of work and 5 minutes of rest.

|Task [[task]]
|A snippet of text specified by the user that can be tracked (done/time spent).

|Pet [[pet]]
|A cute little companion whom the player can care for and accessorise with more tasks being done.

|CLI
|Command Line Interface - a typing interface which is used to interact with the application

|Command
|Executes user input in the application

|CommandBox
|UI component that takes in user input

|ResultDisplay
|UI component that displays the feedback to the user

|FXML
|XML-based user interface markup language for defining user interface of a JaxaFX application

|TaskListCard
|UI component that displays information on an item

|TaskListPanel
|UI component that displays list of items

|JavaFX
|Software platform for creating and delivering desktop applications and rich Internet applications

|JSON
|An open-standard file format that uses human-readable text to transmit data objects consisting of attribute–value pairs and array data types

|Logic
|Handles user input for the application and returns the application’s output

|MainWindow
|Provides the basic application layout containing a pet and CLI sidebar and a task list interface with pomodoro timer

|Model
|Represents and exposes data in the task list, pet, pomodoro and statistics

|Parser
|Converts user input into a Command object

|ReadOnlyTaskList
|Provides an unmodifiable view of a task list

|Storage
|Manages data of the pet, pomodoro, tasklist and statistics in local storage

|Edit distance
|Integer calculated with the levenshtein distance that represents the number of changes to get from one string to another
|===
//end::glossary[]

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

// tag::manualTesting[]
[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. In the home folder for BBproductive, launch the jar file by double clicking on the jar file itself. +
   Expected: Shows the GUI with a set of sample items. The window size may not be optimum.

. Saving user preferences

.. Add or edit tasks accordingly
.. Re-launch the app by double clicking the jar file. +
   Expected:  The same GUI list of tasks appears.

_{ more test cases ... }_

=== Viewing Relevant Screens on command

. On launch
.. Upon double clicking the JAR file, a GUI with the tasks list on the right panel appears.

. On typing stats
.. Type stats in the input command box if you are in either the tasks or settings panel.
... Expected: The right panel shows a GUI with multiple graphs.

. On typing settings
.. Type settings in the input command box if you are in either the tasks or statistics panel.
... Expected: The right panel shows a GUI with multiple fields for the settings.

. On typing tasks
.. Type tasks in the input command box if you are in either the settings or statistics panel.
... Expected: The right panel shows a GUI with the task list.

=== Adding a task
. Adding from a screen with 0 tasks
.. First run `clear` to clear all tasks if there are still tasks on the screen.
.. Add a task by running the command `add n/test1` +
Expected: A task card appears in the tasklist with the name test1.

. Adding from a screen with 1 task
.. Add another task by running the command `add n/test2` +
Expected: A task card appears in the tasklist with the name test2.

=== Editing a task
+ Prerequisite : Run `clear` and add a task using the command `add n/editTest`

. Editing a task's name
.. Run the command `edit 1 n/editedTest`. +
Expected: The command will result in the first task card's name to change from editTest to editedTest.

. Editing a task's description
.. Run the command `edit 1 des/testDescription`. +
Expected: The command will result in the testDescription being the description of the task card.

. Editing a task's priority
.. Run the command `edit 1 p/2`. +
Expected: The command will result in the priority to change from low to medium on the task card.

. Editing a task's tags
.. Run the command `edit 1 t/test`. +
Expected: The command will result in the test tag to appear below the task name on the task card.

=== Adding and triggering a reminder for the task
. Adding a task with a reminder. +
Prerequisite: Take note of the current time plus 1 minute and date in the format `DD/MM/YY@HH:mm`, for example if the current time is `15/03/20@15:47` then you should get the command ready `15/03/20@15:48` (but use the current date and time instead)
.. Run the command `add n/reminderTest des/test r/DD/MM/YY@HH:mm` +
Expected: When the time has arrived a a pop up with a title `reminderTest` and description `test` appears.

. Editing a task to have a reminder. +
Prerequisite: Take note of the current time plus 1 minute and date in the format `DD/MM/YY@HH:mm`, for example if the current time is `15/03/20@15:47` then you should get the command ready `15/03/20@15:48` (but use the current date and time instead)
.. Add a task `add n/editReminderTest des/test` first and see it added on the tasklist panel
.. Take note of the index of that task
.. Edit the task with `edit <index> r/DD/MM/YY@HH:mm` +
Expected: The task displays the reminder date in the task card. When the time comes, a pop up with a title `editReminderTest` and description `test` appears.


=== Adding a recurring attribute to a task
. Adding a task with a recurring attribute. +
.. Run the command `add n/recurTest rec/d`
.. Take note of the index of that task.
.. Run the done command `done <index>` +
Expected: Although it is meant to be a daily recurring task and thus the time delay should be 24 hours, for testing purposes the time delay is set to 60 seconds. After 60 seconds, the done is set back to unfinished, with the tick being removed from the task card.

. Editing a task to have a recurring attribute. +
.. Add a task `add n/editRecurringTest` firs and see it added on the tasklist panel
.. Take note of the index of that task
.. Edit the task with `edit <index> rec/d`
.. Run the done command `done <index>` +
Expected: The task is marked as done at first. After 60 seconds, the done is set back to unfinished, with the tick being removed from the task card.

. Adding a task with a reminder and recurring attribute. +
Prerequisite: Take note of the current time plus 1 minute and date in the format `DD/MM/YY@HH:mm`, for example if the current time is `15/03/20@15:47` then you should get the command ready `15/03/20@15:48` (but use the current date and time instead)
.. Run the command `add n/recurReminderTest r/DD/MM/YY@HH:mm rec/d`
.. Take note of the index of that task.
.. Run the done command `done <index>` +
Expected: After 60 seconds, the done is set back to unfinished, with the tick being removed from the task card. After the reminder appears, the date displayed changes to the next day, for example `15 March at 15:48` changes to `16 March at 15:48`.


=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_


// end::manualTesting[]
