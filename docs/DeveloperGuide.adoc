= AddressBook Level 3 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level3/tree/master

By: `Us`      Since: `Mar 2020`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[width="65%",cols="25%,",options="header",]
|=======================================================================
|Class | Definition
| LandingPage   | First display page for user
| Command controller | Parses and executes user command
| Search        | Class that handles individual user search query
| Model         | Class that handles modelling & report generation
| Storage       | Class that handles all data access
| ??            | Placeholder for whatever we don't know needs to be there.
|=======================================================================

== Class diagram illustration

.Class diagram
image::ClassDiagram.png[]

=== Class definitions

`ContactTracingMainApp` Entry point to launch our contact tracing application

`AppUiManager` Handles rendering information to user and response to user input

`AppMainWindow` Class that sets FXML stage and component arrangements. The class consists of
a `CommandBox` for receiving user input , a `ResultDisplay` for displaying feedback to user
and `BluetoothPingPanel` for rendering search information.

`BluetoothPingPanel` will render different information types, depending on user command.

* `BluetoothPingSummaryPanel` renders all information regarding `BluetoothPing` model
* `PersonSummaryPanel` renders all information regarding `Person` model

`AppLogicManager` handles all backend logic for the application.
It relies on `DaoRouter` to retrieve relevant in-memory storage data.

At present, we only have two kinds of `InMemoryStorage` classes. All `InMemoryStorage` classes
have their data loaded at runtime. Any modifications to the data will not be presisted, in accordance
with project requirements for no internet connectivity.

* `BluetoothPingStorageAccess` stores all collected `BluetoothPing` traces
* `UserStorageAccess` stores all `Person` objects

`CommandRouter` routes user requests to relevant `Command` class types, which form the core
execution logic of the system.

Each `Command` class uses `Conditions` / `Aggregators` classes to drive the implementation of certain logics.
For example, we can have a `FilterDangerCommand` first using the `GroupByIDPairsAggregators` to merge and count
all collect `BluetoothPings` based on their User ID pairs, then pass it through the `DangerConditions` class
to infer which User ID Pairs have had too much contact time.

The return of a successfully executed command is an `AppMessage` class which signals to `AppUiManager`
how the results should be rendered to the user.

== How the architecture components interact with each other

=== User Launches App

.When user issues an instruction to the application
image::SequenceDiagram.png[]

When the user launches the application, his request goes through a series of classes
as illustrated in the figure above.

=== Retrieving command / storage

.Logic for route(request / command)
image::CommandSequenceDiagram.png[]

Figure illustrates how a command is chosen based on a user defined *COMMAND_WORD*.

The exact image can be applied for selecting the data access object we want to use.
Here, the `DaoRouter` infers the type of data access needed by looking at class `AppCommand`.

Routing is done based on whether the `AppCommand` class inherits from `BluetoothPingStorageAccess`
or `UserStorageAccess`.

== Models

All our models are stored and loaded at runtime in memory.

`BluetoothPings` class contains the following fields

[width="65%",cols="25%,",options="header",]
|=======================================================================
|Field name | Description
| epochTs   | Recorded timestamp in Unix Timing
| userIDs   | User pairs [A, B] for each registered device interaction
|=======================================================================

`BluetoothPingsSummary` class is a summary of all user ids recorded

[width="65%",cols="25%,",options="header",]
|=======================================================================
|Field name | Description
| userIDs   | User pairs [A, B] for each registered device interaction
| counts    | Total summed instances of all pairs [A, B] in the database
|=======================================================================

`Person` contains personal details of a user

[width="65%",cols="25%,",options="header",]
|=======================================================================
|Field name | Description
| userID    | Registered user id of the person
| name      | Person's name
| mobile    | Phone number
| nric      | NRIC identification beginning with S and ending with some alphabet
| age       | Person's age
|=======================================================================

== Design Considerations

=== Consideration: How can we extend our platform for customization of search features

* Alternative 1 (Current choice): Introduces concepts such as `conditions` and `aggregations` that are used by AppLogic
** Pros: Clean separation of logic
** Pros: Easily extensible to new conditions
** Cons: Added complexity may cause confusing to new users

* Alternative 2: Define fixed use cases and build code on those features
** Pros: Developers done need to be confused with additional concepts
** Cons: Lack of flexibility and extensibility for new featuress

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Address book lvl 3
This project is a fork of Address-book lvl 3 [ref](https://github.com/nus-cs2103-AY1920S2/addressbook-level3)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Contact tracing app` and the *Actor* is the `user`, unless specified otherwise)

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

Launching the application is as simple as
```java
java -jar <application.jar>
```

. Initial launch

.. Download the jar file and copy into an empty folder
.. Run the command above

   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.
